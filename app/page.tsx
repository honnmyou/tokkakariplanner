"use client"

import { useState, useEffect, useRef } from "react"
import { Plus, Trash2 } from "lucide-react"
import { Button } from "@/components/ui/button"
import { TaskForm } from "@/components/task-form"
import { TaskItem } from "@/components/task-item"
import { UndoToast } from "@/components/undo-toast"
import { TrashModal } from "@/components/trash-modal"
import { InteractiveTutorial } from "@/components/interactive-tutorial"
import type { Task, CompletedTask } from "@/types/task"
import { sortTasksByDueDate } from "@/utils/date-utils"

// Import the TaskBreakdown component
import { TaskBreakdown } from "@/components/task-breakdown"
import { TaskExecution } from "@/components/task-execution"
import { getTaskProgress } from "@/utils/progress-utils"

// Import the StatusBar component
import { StatusBar } from "@/components/status-bar"

// Import storage management utilities
import {
  cleanupCompletedTask,
  performPeriodicCleanup,
  checkStorageHealth,
  STORAGE_KEYS,
  addToTrash,
} from "@/utils/storage-manager"

export default function TokkakariPlanner() {
  const [activeTab, setActiveTab] = useState<"immediate" | "later">("immediate")
  const [tasks, setTasks] = useState<Task[]>([])
  const [isFormOpen, setIsFormOpen] = useState(false)
  const [isTrashOpen, setIsTrashOpen] = useState(false)
  const [completedTask, setCompletedTask] = useState<CompletedTask | null>(null)
  const [showTutorial, setShowTutorial] = useState(false)
  const [tutorialStep, setTutorialStep] = useState("welcome")
  const scrollRef = useRef<HTMLDivElement>(null)

  // Add state for breakdown mode
  const [breakdownTask, setBreakdownTask] = useState<Task | null>(null)

  // Add state for execution mode
  const [executionTask, setExecutionTask] = useState<Task | null>(null)

  // Check if tutorial should be shown on first load - ÂøÖ„ÅöË°®Á§∫„Åô„Çã„Çà„ÅÜ„Å´‰øÆÊ≠£
  useEffect(() => {
    const hasSeenTutorial = localStorage.getItem(STORAGE_KEYS.TUTORIAL_COMPLETED)
    console.log("Tutorial completion status:", hasSeenTutorial)

    // ÂàùÂõûËµ∑ÂãïÊôÇ„ÅØÂøÖ„Åö„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„ÇíË°®Á§∫
    if (!hasSeenTutorial) {
      console.log("First time user - showing tutorial")
      setShowTutorial(true)
    } else {
      console.log("Returning user - tutorial already completed")
      // Êó¢Â≠ò„É¶„Éº„Ç∂„Éº„Åß„ÇÇÊâãÂãï„Åß„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„ÇíÈñãÂßã„Åß„Åç„Çã
    }
  }, [])

  // „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´ÈñãÂßãÊôÇ„Å´„Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„ÇíËøΩÂä†
  useEffect(() => {
    if (showTutorial && tutorialStep === "welcome") {
      // „Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„ÇíËøΩÂä†
      const sampleTask: Task = {
        id: "tutorial-sample-task",
        title: "ÊéàÊ•≠„Ç¢„É≥„Ç±„Éº„Éà„ÇíÊèêÂá∫„Åô„Çã",
        completed: false,
        category: "immediate",
        createdAt: new Date(),
      }

      // Êó¢Â≠ò„ÅÆ„Çø„Çπ„ÇØ„Å´„Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøËøΩÂä†
      setTasks((prev) => {
        const hasSampleTask = prev.some((task) => task.id === "tutorial-sample-task")
        if (!hasSampleTask) {
          return [sampleTask, ...prev]
        }
        return prev
      })
    }
  }, [showTutorial, tutorialStep])

  // Load tasks from localStorage on mount and perform cleanup
  useEffect(() => {
    try {
      // „Çπ„Éà„É¨„Éº„Ç∏„ÅÆÂÅ•ÂÖ®ÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
      checkStorageHealth()

      // ÂÆöÊúü„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÇíÂÆüË°å
      performPeriodicCleanup()

      // „Çø„Çπ„ÇØ„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø
      const savedTasks = localStorage.getItem(STORAGE_KEYS.TASKS)
      if (savedTasks) {
        const parsedTasks = JSON.parse(savedTasks).map((task: any) => ({
          ...task,
          dueDate: task.dueDate ? new Date(task.dueDate) : undefined,
          createdAt: new Date(task.createdAt),
        }))
        setTasks(parsedTasks)
        console.log(`üìã Loaded ${parsedTasks.length} tasks from localStorage`)
      }
    } catch (error) {
      console.error("‚ùå Failed to load tasks from localStorage:", error)
      // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅØÁ©∫„ÅÆÈÖçÂàó„ÅßÂàùÊúüÂåñ
      setTasks([])
    }
  }, [])

  // Save tasks to localStorage whenever tasks change („ÉÅ„É•„Éº„Éà„É™„Ç¢„É´‰∏≠„ÅØ‰øùÂ≠ò„Åó„Å™„ÅÑ)
  useEffect(() => {
    // „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´‰∏≠„ÅØ„Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„Çí‰øùÂ≠ò„Åó„Å™„ÅÑ
    if (showTutorial) return

    try {
      // „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´Áî®„ÅÆ„Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„ÇíÈô§Â§ñ„Åó„Å¶‰øùÂ≠ò
      const tasksToSave = tasks.filter((task) => task.id !== "tutorial-sample-task")
      localStorage.setItem(STORAGE_KEYS.TASKS, JSON.stringify(tasksToSave))
      console.log(`üíæ Saved ${tasksToSave.length} tasks to localStorage`)

      // „Çπ„Éà„É¨„Éº„Ç∏‰ΩøÁî®Èáè„Çí„ÉÅ„Çß„ÉÉ„ÇØ
      checkStorageHealth()
    } catch (error) {
      console.error("‚ùå Failed to save tasks to localStorage:", error)

      // ÂÆπÈáè‰∏çË∂≥„ÅÆÂ†¥Âêà„ÅØÁ∑äÊÄ•„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÇíË©¶Ë°å
      if (error instanceof Error && error.name === "QuotaExceededError") {
        console.log("üö® Storage quota exceeded, performing cleanup...")
        const { emergencyCleanup } = require("@/utils/storage-manager")
        emergencyCleanup()

        // ÂÜçÂ∫¶‰øùÂ≠ò„ÇíË©¶Ë°å
        try {
          const tasksToSave = tasks.filter((task) => task.id !== "tutorial-sample-task")
          localStorage.setItem(STORAGE_KEYS.TASKS, JSON.stringify(tasksToSave))
          console.log("‚úÖ Successfully saved after cleanup")
        } catch (retryError) {
          console.error("‚ùå Failed to save even after cleanup:", retryError)
        }
      }
    }
  }, [tasks, showTutorial])

  // Reset scroll position when switching tabs
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = 0
    }
  }, [activeTab])

  // Monitor tab switching for tutorial - waitForAction„ÅÆ„Åø
  useEffect(() => {
    if (showTutorial && tutorialStep === "tabs-explanation" && activeTab === "later") {
      setTimeout(() => handleTutorialStepComplete("tabs-explanation"), 500)
    }

    // „Äå„Åæ„ÅöÊúÄÂàù„Å´„ÇÑ„Çã‰∫ã„Äç„Çø„Éñ„Å∏„ÅÆÂàá„ÇäÊõø„Åà„ÇíÁõ£Ë¶ñ
    if (showTutorial && tutorialStep === "tab-switch-back" && activeTab === "immediate") {
      setTimeout(() => handleTutorialStepComplete("tab-switch-back"), 500)
    }
  }, [activeTab, tutorialStep, showTutorial])

  // Tutorial step progression - task-completed-celebration„ÇíÂâäÈô§
  const handleTutorialStepComplete = (step: string) => {
    console.log("Main page: Tutorial step completed:", step)

    const stepOrder = [
      "welcome",
      "tabs-explanation",
      "tab-switch",
      "tab-switch-back",
      "simple-task-explanation", // Êñ∞„Åó„ÅÑ„Çπ„ÉÜ„ÉÉ„Éó„ÇíËøΩÂä†
      "simple-task-completion",
      "undo-explanation",
      "add-task-button",
      "task-form-explanation",
      "task-breakdown",
      "breakdown-screen",
      "voice-input",
      "voice-input-demo",
      "breakdown-submit",
      "breakdown-results",
      "start-execution",
      "execution-overview",
      "current-task-explanation",
      "complete-first-task",
      "interrupt-explanation",
      "tutorial-skip-notice",
      "complete",
    ]

    const currentIndex = stepOrder.indexOf(step)
    console.log("Main page: Current step index:", currentIndex)

    if (currentIndex < stepOrder.length - 1) {
      const nextStep = stepOrder[currentIndex + 1]
      console.log("Main page: Moving to next step:", nextStep)
      setTutorialStep(nextStep)
    } else {
      handleTutorialComplete()
    }
  }

  // Monitor form open for tutorial - waitForAction„ÅÆ„Åø
  useEffect(() => {
    if (showTutorial && tutorialStep === "add-task-button" && isFormOpen) {
      setTimeout(() => handleTutorialStepComplete("add-task-button"), 500)
    }
  }, [isFormOpen, tutorialStep, showTutorial])

  // Monitor task addition for tutorial - waitForAction„ÅÆ„Åø
  useEffect(() => {
    if (showTutorial && tutorialStep === "task-form-explanation") {
      // „Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ‰ª•Â§ñ„ÅÆ„Çø„Çπ„ÇØ„ÅåËøΩÂä†„Åï„ÇåÔøΩÔøΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
      const userTasks = tasks.filter((task) => task.id !== "tutorial-sample-task")
      if (userTasks.length > 0) {
        setTimeout(() => handleTutorialStepComplete("task-form-explanation"), 1000)
      }
    }
  }, [tasks, tutorialStep, showTutorial])

  // Monitor simple task completion for tutorial - waitForAction„ÅÆ„Åø
  useEffect(() => {
    if (showTutorial && tutorialStep === "simple-task-completion" && completedTask?.id === "tutorial-sample-task") {
      setTimeout(() => handleTutorialStepComplete("simple-task-completion"), 1000)
    }
  }, [completedTask, tutorialStep, showTutorial])

  // Monitor breakdown screen for tutorial - waitForAction„ÅÆ„Åø
  useEffect(() => {
    if (showTutorial && tutorialStep === "task-breakdown" && breakdownTask) {
      setTimeout(() => handleTutorialStepComplete("task-breakdown"), 500)
    }
  }, [breakdownTask, tutorialStep, showTutorial])

  // Monitor execution screen for tutorial - waitForAction„ÅÆ„Åø
  useEffect(() => {
    if (showTutorial && tutorialStep === "start-execution" && executionTask) {
      setTimeout(() => handleTutorialStepComplete("start-execution"), 500)
    }
  }, [executionTask, tutorialStep, showTutorial])

  const handleAddTask = (title: string, dueDate?: Date, category?: "immediate" | "later") => {
    const newTask: Task = {
      id: Date.now().toString(),
      title,
      completed: false,
      dueDate,
      category: category || activeTab,
      createdAt: new Date(),
    }
    setTasks((prev) => [...prev, newTask])
  }

  const handleToggleComplete = (id: string) => {
    const task = tasks.find((t) => t.id === id)
    if (!task) return

    if (!task.completed) {
      // Mark as completed and set up auto-delete
      setTasks((prev) => prev.map((t) => (t.id === id ? { ...t, completed: true } : t)))

      const completedTaskData: CompletedTask = {
        ...task,
        completed: true,
        completedAt: new Date(),
      }

      // Set up auto-delete after 5 seconds (changed from 3 seconds)
      const timer = setTimeout(() => {
        // „Çø„Çπ„ÇØ„Çí„É™„Çπ„Éà„Åã„ÇâÂâäÈô§
        setTasks((prev) => prev.filter((t) => t.id !== id))

        // „Ç¥„ÉüÁÆ±„Å´ËøΩÂä†Ôºà„Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„ÅØÈô§„ÅèÔºâ
        if (id !== "tutorial-sample-task") {
          addToTrash({
            id: task.id,
            title: task.title,
            deletedAt: new Date(),
            category: task.category,
          })
        }

        // Èñ¢ÈÄ£„Åô„ÇãlocalStorage„Éá„Éº„Çø„ÇÇÂâäÈô§Ôºà„Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„ÅØÈô§„ÅèÔºâ
        if (id !== "tutorial-sample-task") {
          cleanupCompletedTask(id)
        }

        setCompletedTask(null)

        console.log(`üóëÔ∏è Auto-deleted completed task: ${task.title}`)
      }, 5000) // Changed from 3000 to 5000

      completedTaskData.autoDeleteTimer = timer
      setCompletedTask(completedTaskData)

      // Tutorial: task completion - waitForAction„ÅÆ„Åø
      if (showTutorial && tutorialStep === "complete-first-task") {
        setTimeout(() => handleTutorialStepComplete("complete-first-task"), 1000)
      }
    } else {
      // Mark as incomplete
      setTasks((prev) => prev.map((t) => (t.id === id ? { ...t, completed: false } : t)))

      // Clear any pending deletion
      if (completedTask?.id === id && completedTask.autoDeleteTimer) {
        clearTimeout(completedTask.autoDeleteTimer)
        setCompletedTask(null)
      }
    }
  }

  const handleEditTask = (id: string, title: string, dueDate?: Date) => {
    setTasks((prev) => prev.map((t) => (t.id === id ? { ...t, title, dueDate } : t)))
  }

  const handleDeleteTask = (id: string) => {
    const task = tasks.find((t) => t.id === id)
    if (!task) return

    // „Çø„Çπ„ÇØ„Çí„É™„Çπ„Éà„Åã„ÇâÂâäÈô§
    setTasks((prev) => prev.filter((t) => t.id !== id))

    // „Ç¥„ÉüÁÆ±„Å´ËøΩÂä†Ôºà„Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„ÅØÈô§„ÅèÔºâ
    if (id !== "tutorial-sample-task") {
      addToTrash({
        id: task.id,
        title: task.title,
        deletedAt: new Date(),
        category: task.category,
      })
    }

    // Èñ¢ÈÄ£„Åô„ÇãlocalStorage„Éá„Éº„Çø„ÇÇÂâäÈô§Ôºà„Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„ÅØÈô§„ÅèÔºâ
    if (id !== "tutorial-sample-task") {
      cleanupCompletedTask(id)
    }

    console.log(`üóëÔ∏è Manually deleted task: ${task.title}`)
  }

  const handleUndoDelete = () => {
    if (completedTask?.autoDeleteTimer) {
      clearTimeout(completedTask.autoDeleteTimer)
      setTasks((prev) => prev.map((t) => (t.id === completedTask.id ? { ...t, completed: false } : t)))
      setCompletedTask(null)
      console.log(`‚Ü©Ô∏è Undid deletion for task: ${completedTask.title}`)
    }
  }

  const handleCloseUndoToast = () => {
    setCompletedTask(null)
  }

  // Add handler for opening task breakdown
  const handleOpenBreakdown = (id: string) => {
    const task = tasks.find((t) => t.id === id)
    if (task) {
      setBreakdownTask(task)
    }
  }

  // Add handler for execution (ÂàÜËß£Ê∏à„Åø„Çø„Çπ„ÇØ„ÅÆ„Åø)
  const handleExecuteBreakdownTask = (id: string) => {
    const task = tasks.find((t) => t.id === id)
    if (task) {
      // ‰øùÂ≠ò„Åï„Çå„ÅüÈÄ≤Êçó„Åã„ÇâÂàÜËß£„Åï„Çå„Åü„Çø„Çπ„ÇØ„ÇíÂèñÂæó
      const savedProgress = getTaskProgress(task.id)
      if (savedProgress && savedProgress.generatedTasks.length > 0) {
        // ‰øùÂ≠ò„Åï„Çå„ÅüÈÄ≤Êçó„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Åù„Çå„Çí‰ΩøÁî®
        setExecutionTask({
          ...task,
          generatedTasks: savedProgress.generatedTasks,
        })
        console.log("Opening execution with saved progress:", savedProgress)
      } else if (task.isBreakdown && task.generatedTasks) {
        // ‰øùÂ≠ò„Åï„Çå„ÅüÈÄ≤Êçó„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Çø„Çπ„ÇØ„ÅÆgeneratedTasks„Çí‰ΩøÁî®
        setExecutionTask(task)
        console.log("Opening execution with task generatedTasks:", task.generatedTasks)
      } else {
        console.error("No generated tasks found for breakdown task:", task)
      }
    }
  }

  const handleTasksGenerated = (taskTitles: string[], isBreakdown = false) => {
    const newTasks: Task[] = taskTitles.map((title) => ({
      id: Date.now().toString() + Math.random(),
      title,
      completed: false,
      category: breakdownTask?.category || activeTab,
      createdAt: new Date(),
    }))
    setTasks((prev) => [...prev, ...newTasks])

    // ÂÖÉ„ÅÆ„Çø„Çπ„ÇØ„ÇíÂàÜËß£Ê∏à„Åø„Å®„Åó„Å¶„Éû„Éº„ÇØ
    if (isBreakdown && breakdownTask) {
      setTasks((prev) =>
        prev.map((t) => (t.id === breakdownTask.id ? { ...t, isBreakdown: true, generatedTasks: taskTitles } : t)),
      )
    }
  }

  // ÁîªÈù¢Ôºë„Å´Êàª„Çã„Åü„ÇÅ„ÅÆ„Éè„É≥„Éâ„É©„Éº
  const handleBackToHome = () => {
    setBreakdownTask(null)
    setExecutionTask(null)
    setActiveTab("immediate")
  }

  // „Çø„Çπ„ÇØÂÆå‰∫ÜÊôÇ„ÅÆ„Éè„É≥„Éâ„É©„ÉºÔºàÂÖ®„Çø„Çπ„ÇØÂÆå‰∫ÜÊôÇÔºâ
  const handleTaskCompleted = (taskId: string) => {
    // „Çø„Çπ„ÇØ„ÇíÂâäÈô§
    setTasks((prev) => prev.filter((t) => t.id !== taskId))

    // Èñ¢ÈÄ£„Åô„ÇãlocalStorage„Éá„Éº„Çø„ÇÇÂâäÈô§
    cleanupCompletedTask(taskId)

    // ÁîªÈù¢Ôºë„Å´Êàª„Çã
    handleBackToHome()

    console.log(`üéâ Completed and cleaned up task: ${taskId}`)
  }

  // Tutorial handlers
  const handleTutorialComplete = () => {
    try {
      localStorage.setItem(STORAGE_KEYS.TUTORIAL_COMPLETED, "true")
      setShowTutorial(false)

      // „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´ÂÆå‰∫ÜÊôÇ„Å´„Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„ÇíÂâäÈô§
      setTasks((prev) => prev.filter((task) => task.id !== "tutorial-sample-task"))

      console.log("‚úÖ Tutorial completed and saved")
    } catch (error) {
      console.error("‚ùå Failed to save tutorial completion:", error)
      setShowTutorial(false)
    }
  }

  const handleTutorialSkip = () => {
    setShowTutorial(false)
    // „Çπ„Ç≠„ÉÉ„ÉóÊôÇ„ÇÇ„Çµ„É≥„Éó„É´„Çø„Çπ„ÇØ„ÇíÂâäÈô§
    setTasks((prev) => prev.filter((task) => task.id !== "tutorial-sample-task"))
  }

  // „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´‰∏≠„Å´ÁâπÂÆö„ÅÆ„Éú„Çø„É≥„ÅåÊúâÂäπ„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö„Åô„ÇãÈñ¢Êï∞
  const isTutorialButtonEnabled = (buttonType: string, taskId?: string): boolean => {
    if (!showTutorial) return true

    switch (tutorialStep) {
      case "welcome":
        return false // Ê¨°„Å∏„Éú„Çø„É≥„ÅÆ„ÅøÊúâÂäπ
      case "tabs-explanation":
        return buttonType === "tab-later"
      case "tab-switch":
        return false // Ê¨°„Å∏„Éú„Çø„É≥„ÅÆ„ÅøÊúâÂäπ
      case "tab-switch-back":
        return buttonType === "tab-immediate"
      case "simple-task-explanation":
        return false // Ê¨°„Å∏„Éú„Çø„É≥„ÅÆ„ÅøÊúâÂäπ
      case "simple-task-completion":
        return buttonType === "task-check" && taskId === "tutorial-sample-task"
      case "undo-explanation":
        return buttonType === "undo-button"
      case "add-task-button":
        return buttonType === "add-task"
      case "task-form-explanation":
        return buttonType === "task-form-submit"
      case "task-breakdown":
        return buttonType === "task-breakdown" && taskId !== "tutorial-sample-task"
      case "breakdown-screen":
      case "voice-input":
      case "voice-input-demo":
      case "breakdown-submit":
        return buttonType === "breakdown-submit" || buttonType === "voice-input" || buttonType === "text-input"
      case "breakdown-results":
        return buttonType === "start-execution" || buttonType === "task-edit" || buttonType === "task-reorder"
      case "start-execution":
        return buttonType === "start-execution"
      case "execution-overview":
      case "current-task-explanation":
        return false // Ê¨°„Å∏„Éú„Çø„É≥„ÅÆ„ÅøÊúâÂäπ
      case "complete-first-task":
        return buttonType === "current-task-check"
      case "interrupt-explanation":
        return buttonType === "interrupt-button"
      case "tutorial-skip-notice":
      case "complete":
        return false // ÂÆå‰∫Ü„Éú„Çø„É≥„ÅÆ„ÅøÊúâÂäπ
      default:
        return false
    }
  }

  const currentTasks = sortTasksByDueDate(tasks.filter((task) => task.category === activeTab))
  const accentColor = activeTab === "immediate" ? "text-red-500" : "text-blue-500"
  const buttonColor = activeTab === "immediate" ? "bg-red-500 hover:bg-red-600" : "bg-blue-500 hover:bg-blue-600"

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col japanese-text">
      {/* Status Bar */}
      <StatusBar />

      {/* Header */}
      <div className="bg-white px-4 text-center flex-shrink-0 py-6 border-b">
        <div className="flex items-center relative justify-center mb-[-15px]">
          <img src="/images/yarn-ball-logo.png" alt="„Å®„Å£„Åã„Åã„Çä„Éó„É©„É≥„Éä„Éº „É≠„Ç¥" className="w-16 h-16" />
          {/* Trash Button */}
          <Button
            variant="ghost"
            size="icon"
            onClick={() => setIsTrashOpen(true)}
            className="absolute right-0 top-0 text-gray-400 hover:text-gray-600 hover:bg-gray-100"
            disabled={showTutorial}
          >
            <Trash2 className="w-5 h-5" />
          </Button>
        </div>
        <h1 className="font-bold app-title font-mono text-lg text-gray-900">tokkakari</h1>
        <button
          onClick={() => setShowTutorial(true)}
          className="mt-2 text-xs text-gray-500 hover:text-gray-700 transition-colors font-bold"
        >
          „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„ÇíË¶ã„Çã
        </button>
      </div>

      {/* Tabs */}
      <div className="tabs-container bg-white flex-shrink-0">
        <div className="flex">
          <button
            onClick={() => setActiveTab("immediate")}
            disabled={!isTutorialButtonEnabled("tab-immediate")}
            className={`tab-immediate flex-1 py-4 px-4 text-center font-bold tab-text border-b-2 transition-colors ${
              activeTab === "immediate" ? "border-b-2" : "text-gray-600 border-transparent"
            } ${!isTutorialButtonEnabled("tab-immediate") ? "opacity-50 cursor-not-allowed" : ""}`}
            style={{
              color: activeTab === "immediate" ? "#FF5F68" : "#444444",
              borderBottomColor: activeTab === "immediate" ? "#FF5F68" : "transparent",
            }}
          >
            „Åæ„ÅöÊúÄÂàù„Å´„ÇÑ„Çã‰∫ã
          </button>
          <button
            onClick={() => setActiveTab("later")}
            disabled={!isTutorialButtonEnabled("tab-later")}
            className={`tab-later flex-1 py-4 px-4 text-center font-bold tab-text border-b-2 transition-colors ${
              activeTab === "later" ? "border-b-2" : "text-gray-600 border-transparent"
            } ${!isTutorialButtonEnabled("tab-later") ? "opacity-50 cursor-not-allowed" : ""}`}
            style={{
              color: activeTab === "later" ? "#007AFF" : "#444444",
              borderBottomColor: activeTab === "later" ? "#007AFF" : "transparent",
            }}
          >
            Âæå„Åß„Åò„Å£„Åè„ÇäËÄÉ„Åà„Çã‰∫ã
          </button>
        </div>
      </div>

      {/* Content - „Çπ„ÇØ„É≠„Éº„É´ÂèØËÉΩ */}
      <div ref={scrollRef} className="flex-1 overflow-y-auto">
        <div className="p-4 pb-32">
          <h2 className="text-lg font-bold mb-6" style={{ color: activeTab === "immediate" ? "#FF5F68" : "#007AFF" }}>
            {activeTab === "immediate" ? "„Åæ„ÅöÊúÄÂàù„Å´„ÇÑ„Çã„Åì„Å®" : "Âæå„Åß„Åò„Å£„Åè„ÇäËÄÉ„Åà„Çã„Åì„Å®"}
          </h2>

          <div className="space-y-3">
            {currentTasks.map((task) => (
              <TaskItem
                key={task.id}
                task={task}
                onToggleComplete={handleToggleComplete}
                onEdit={handleEditTask}
                onDelete={handleDeleteTask}
                onBreakdown={handleOpenBreakdown}
                onExecute={handleExecuteBreakdownTask}
                accentColor={accentColor}
                tutorialStep={showTutorial ? tutorialStep : null}
                showTutorial={showTutorial}
              />
            ))}

            {currentTasks.length === 0 && (
              <div className="text-center py-12 text-gray-500">
                <p className="font-bold">„Çø„Çπ„ÇØ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>
                <p className="text-sm mt-1 font-bold">+ „Éú„Çø„É≥„Åß„Çø„Çπ„ÇØ„ÇíËøΩÂä†„Åó„Åæ„Åó„Çá„ÅÜ</p>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Floating Action Button */}
      <Button
        className={`add-task-button fixed bottom-6 right-6 w-14 h-14 rounded-full shadow-lg z-10 font-bold ${
          !isTutorialButtonEnabled("add-task") ? "opacity-50 cursor-not-allowed" : ""
        }`}
        style={{
          backgroundColor: activeTab === "immediate" ? "#FF5F68" : "#007AFF",
          color: "#FFFFFF",
        }}
        size="icon"
        onClick={() => setIsFormOpen(true)}
        disabled={!isTutorialButtonEnabled("add-task")}
      >
        <Plus className="w-6 h-6" />
      </Button>

      {/* Task Form Modal */}
      <TaskForm
        isOpen={isFormOpen}
        onClose={() => setIsFormOpen(false)}
        onSubmit={handleAddTask}
        category={activeTab}
        tutorialStep={showTutorial ? tutorialStep : null}
        onTutorialStepComplete={handleTutorialStepComplete}
      />

      {/* Trash Modal */}
      <TrashModal isOpen={isTrashOpen} onClose={() => setIsTrashOpen(false)} />

      {/* Undo Toast */}
      <UndoToast
        isVisible={!!completedTask}
        taskTitle={completedTask?.title || ""}
        onUndo={handleUndoDelete}
        onClose={handleCloseUndoToast}
      />

      {/* Interactive Tutorial */}
      <InteractiveTutorial
        isActive={showTutorial}
        currentStep={tutorialStep}
        onComplete={handleTutorialComplete}
        onSkip={handleTutorialSkip}
        onStepComplete={handleTutorialStepComplete}
      />

      {breakdownTask && (
        <div className="fixed inset-0 bg-white z-50">
          <TaskBreakdown
            task={breakdownTask}
            onBack={() => setBreakdownTask(null)}
            onTasksGenerated={handleTasksGenerated}
            onBackToHome={handleBackToHome}
            onTaskCompleted={handleTaskCompleted}
            tutorialStep={showTutorial ? tutorialStep : null}
            onTutorialStepComplete={handleTutorialStepComplete}
          />
        </div>
      )}

      {executionTask && (
        <div className="fixed inset-0 bg-white z-50">
          <TaskExecution
            task={executionTask}
            generatedTasks={executionTask.generatedTasks || []}
            onBack={() => setExecutionTask(null)}
            onBackToHome={handleBackToHome}
            onTaskCompleted={handleTaskCompleted}
            tutorialStep={showTutorial ? tutorialStep : null}
            onTutorialStepComplete={handleTutorialStepComplete}
            onAddTask={(title) => {
              const newTask: Task = {
                id: Date.now().toString() + Math.random(),
                title,
                completed: false,
                category: executionTask?.category || activeTab,
                createdAt: new Date(),
              }
              setTasks((prev) => [...prev, ...newTask])
            }}
          />
        </div>
      )}
    </div>
  )
}
